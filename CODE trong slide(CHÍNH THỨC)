#include <WiFi.h>
#include <WebServer.h>
#include <SD.h>
#include <vector>
#include <cmath>

#define BUTTON_PIN 33
#define LED_PIN 2
#define SD_CS 5
#define ADC_PIN 34 // Pin ADC kết nối với cảm biến MAX4466

const char* ssid = "vip1";
const char* password = "123456789";

WebServer server(80);
bool isRecording = false;
File wavFile;
String lastRecordedFile;
std::vector<String> recordedFiles;
const int sampleRate = 44100;
const int bitsPerSample = 16;
const int channels = 1;
const int adcBufferSize = 512;

void writeWAVHeader(File file, int sampleRate, int bitsPerSample, int channels, int dataSize) {
    file.write((const uint8_t*)"RIFF", 4);
    int fileSize = 36 + dataSize;
    file.write((byte*)&fileSize, 4);
    file.write((const uint8_t*)"WAVE", 4);

    file.write((const uint8_t*)"fmt ", 4);
    int fmtChunkSize = 16;
    file.write((byte*)&fmtChunkSize, 4);
    int16_t audioFormat = 1;
    int16_t numChannels = channels;
    file.write((byte*)&audioFormat, 2);
    file.write((byte*)&numChannels, 2);

    file.write((byte*)&sampleRate, 4);
    int32_t byteRate = sampleRate * channels * bitsPerSample / 8;
    file.write((byte*)&byteRate, 4);

    int16_t blockAlign = channels * bitsPerSample / 8;
    file.write((byte*)&blockAlign, 2);
    file.write((byte*)&bitsPerSample, 2);

    file.write((const uint8_t*)"data", 4);
    file.write((byte*)&dataSize, 4);
}

void startRecording() {
    lastRecordedFile = "/audio_" + String(millis()) + ".wav";
    wavFile = SD.open(lastRecordedFile.c_str(), FILE_WRITE);
    if (!wavFile) {
        Serial.println("Failed to create file");
        return;
    }
    writeWAVHeader(wavFile, sampleRate, bitsPerSample, channels, 0);
    recordedFiles.push_back(lastRecordedFile);
    isRecording = true;
    digitalWrite(LED_PIN, HIGH);
    Serial.println("Recording started");
}

void stopRecording() {
    if (!isRecording) return;

    isRecording = false;
    int dataSize = wavFile.size() - 44;
    wavFile.seek(4);
    int fileSize = 36 + dataSize;
    wavFile.write((byte*)&fileSize, 4);

    wavFile.seek(40);
    wavFile.write((byte*)&dataSize, 4);

    wavFile.close();
    digitalWrite(LED_PIN, LOW);
    Serial.println("Recording stopped");
}

void displaySignalLevel(int16_t* buffer, size_t length) {
    long sumSquares = 0;
    for (int i = 0; i < length; i++) {
        sumSquares += buffer[i] * buffer[i];
    }
    float rms = sqrt(sumSquares / length);
    int level = map(rms, 0, 32767, 0, 255);
    analogWrite(LED_PIN, level);

    // Gửi dữ liệu mức tín hiệu lên Serial Plotter
    Serial.print("SignalLevel:");
    Serial.println(level);

    Serial.print("RMS:");
    Serial.println(rms); // Gửi RMS để vẽ trên Serial Plotter
}

void handleAudioList() {
    String html = "<html><body><h1>Recorded Files</h1><ul>";
    for (const auto& fileName : recordedFiles) {
        html += "<li><a href='/download?file=" + fileName + "'>" + fileName + "</a></li>";
    }
    html += "</ul></body></html>";
    server.send(200, "text/html", html);
}

void handleAudioDownload() {
    String fileName = server.arg("file");
    if (SD.exists(fileName)) {
        File file = SD.open(fileName, FILE_READ);
        server.sendHeader("Content-Type", "application/octet-stream");
        server.sendHeader("Content-Disposition", "attachment; filename=" + fileName);
        server.streamFile(file, "application/octet-stream");
        file.close();
    } else {
        server.send(404, "text/plain", "No file found");
    }
}

void setupWebServer() {
    server.on("/", handleAudioList);
    server.on("/download", handleAudioDownload);
    server.begin();
}

void setup() {
    Serial.begin(115200);

    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);

    WiFi.softAP(ssid, password);
    Serial.print("IP address: ");
    Serial.println(WiFi.softAPIP());

    if (!SD.begin(SD_CS)) {
        Serial.println("SD card init failed!");
        return;
    }

    setupWebServer();
    Serial.println("Setup completed");
}

void loop() {
    static bool buttonState = HIGH;
    bool currentButtonState = digitalRead(BUTTON_PIN);

    if (currentButtonState == LOW && buttonState == HIGH) {
        if (!isRecording) {
            startRecording();
        } else {
            stopRecording();
        }
    }

    buttonState = currentButtonState;

    if (isRecording) {
        int16_t adcBuffer[adcBufferSize];
        for (int i = 0; i < adcBufferSize; i++) {
            adcBuffer[i] = analogRead(ADC_PIN) - 2048; // Đọc giá trị từ ADC và chuyển đổi thành giá trị âm dương
        }
        wavFile.write((byte*)adcBuffer, sizeof(adcBuffer));
        displaySignalLevel(adcBuffer, adcBufferSize);
    }

    server.handleClient();
}
